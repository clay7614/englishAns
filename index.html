<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>英語4択ドリル</title>
  <link rel="stylesheet" href="styles.css">
  </head>
<body>
  <main class="app">
    <header class="app__header">
      <h1>英語4択ドリル</h1>
      <p class="app__status" data-status>問題を読み込み中...</p>
    </header>
    <section class="translation-toggle" data-translation-choice hidden>
      <p class="translation-toggle__prompt">日本語訳を表示しますか？</p>
      <div class="translation-toggle__buttons">
        <button type="button" class="translation-toggle__button" data-translation-option="show">表示する</button>
        <button type="button" class="translation-toggle__button translation-toggle__button--secondary" data-translation-option="hide">表示しない</button>
      </div>
    </section>
    <section class="quiz" data-quiz hidden>
      <div class="quiz__score"><span data-correct>0</span> / <span data-total>0</span> 正解</div>
      <div class="quiz__question" data-question></div>
      <div class="quiz__options" data-options></div>
      <div class="quiz__feedback" data-feedback></div>
      <div class="quiz__controls">
        <button type="button" class="quiz__control-button" data-toggle-timer>自動で進む: ON</button>
        <button type="button" class="quiz__control-button" data-toggle-translation>日本語: 非表示</button>
        <button type="button" class="quiz__control-button" data-toggle-mode disabled>誤答のみ: OFF</button>
        <button type="button" class="quiz__control-button" data-shuffle-order disabled>順番をシャッフル</button>
        <button type="button" class="quiz__next" data-next disabled>次の問題へ</button>
      </div>
    </section>
  </main>

  <template id="option-button-template">
    <button type="button" class="quiz__option"></button>
  </template>

  <script type="module">
    const QUESTION_DATASETS = [
      {
        id: 'set-601-750',
        title: '英語4択 601-750',
        questionFile: '601~750_en.csv',
        translationFile: 'translations-ja.json',
      },
    ];

    const OPTION_TRANSLATION_FALLBACKS = new Map([
      ['', '（空欄）'],
      ['about', '～について'],
      ['Actually', '実は'],
      ['actually', '実際に'],
      ['able', 'できる'],
      ['Almost', 'ほとんど'],
      ['almost', 'ほとんど'],
      ['aluminium', 'アルミニウム'],
      ['an eye on', '見張る'],
      ['announce', '発表する'],
      ['announcement', '発表'],
      ['announcer', 'アナウンサー'],
      ['announcing', '発表している'],
      ['at', '～で'],
      ['atmosphere', '大気'],
      ['authority', '権威'],
      ['aware', '気づいている'],
      ['away', '離れて'],
      ['away from', '～から離れて'],
      ['back', '戻って'],
      ['bit', '少し'],
      ['bitten', '噛まれた'],
      ['bloom', '花が咲く'],
      ['bloomed', '花が咲いた'],
      ['blooms', '花'],
      ['blossom', '花が咲く'],
      ['blossoms', '花々'],
      ['board', '板'],
      ['bored', '退屈した'],
      ['boring', '退屈な'],
      ['borrow', '借りる'],
      ['borrowing', '借りること'],
      ['branch', '枝'],
      ['branches', '枝'],
      ['bring', '持ってくる'],
      ['Bring', '持ってきて'],
      ['certain', '確かな'],
      ['Certain', '確かな'],
      ['Certainly', '確かに'],
      ['clear', '明確な'],
      ['Clear', 'はっきりさせる'],
      ['clerk', '事務員'],
      ['Clerks', '事務員たち'],
      ['convenient', '都合がよい'],
      ['copper', '銅'],
      ['dead', '死んだ'],
      ['deliver', '配達する'],
      ['delivered', '配達した'],
      ['desert', '砂漠'],
      ['did', 'した'],
      ['digging', '掘っている'],
      ['doctor', '医者'],
      ['Doctors', '医者たち'],
      ['down', '下へ'],
      ['dug', '掘った'],
      ['earthquake', '地震'],
      ['earthquakes', '地震'],
      ['ectra', '余分な（誤字）'],
      ['empty', '空の'],
      ['engineer', '技師'],
      ['equal', '等しい'],
      ['equality', '平等'],
      ['equally', '均等に'],
      ['Especially', '特に'],
      ['especially', '特に'],
      ['excited', '興奮した'],
      ['exciting', 'わくわくさせる'],
      ['extra', '余分な'],
      ['fail', '失敗する'],
      ['failed', '失敗した'],
      ['failing', '失敗すること'],
      ['familiar', 'よく知っている'],
      ['famous', '有名な'],
      ['fear', '恐れ'],
      ['feature', '特徴'],
      ['features', '特徴'],
      ['field', '野原'],
      ['filled', '満たした'],
      ['for', '～のために'],
      ['fresh', '新鮮な'],
      ['friends with', '～と友達になる'],
      ['from', '～から'],
      ['full', 'いっぱいの'],
      ['fun of', '～をからかう'],
      ['ghosts', '幽霊'],
      ['gold', '金'],
      ['guide', '案内人'],
      ['hardly', 'ほとんど～ない'],
      ['Hardly', 'ほとんど～ない'],
      ['her', '彼女を'],
      ['herself', '彼女自身'],
      ['himself', '彼自身'],
      ['hire', '雇う'],
      ['hired', '雇った'],
      ['hit', '打つ'],
      ['hunt', '狩る'],
      ['hunted', '狩った'],
      ['ill', '病気の'],
      ['impossible', '不可能な'],
      ['in', '～の中で'],
      ['in torch with', '連絡を取る（誤記）'],
      ['injured', 'けがをした'],
      ['injuring', 'けがをさせること'],
      ['interested', '興味がある'],
      ['interesting', '興味深い'],
      ['interestingly', '興味深いことに'],
      ['keep', '保つ'],
      ['keep an eye on', '見張る'],
      ['keep in touch with', '連絡を取り合う'],
      ['keep on', '～し続ける'],
      ['keep up with', '遅れずについていく'],
      ['keeping', '保つこと'],
      ['kept', '保った'],
      ['knowledge', '知識'],
      ['laugh', '笑う'],
      ['laughed', '笑った'],
      ['laughing', '笑っている'],
      ['leader', '指導者'],
      ['leaders', '指導者たち'],
      ['leadership', '指導力'],
      ['lean', 'もたれる'],
      ['leaned', 'もたれた'],
      ['leaning', 'もたれている'],
      ['least', '最も少ない'],
      ['lend', '貸す'],
      ['lending', '貸すこと'],
      ['lent', '貸した'],
      ['less', 'より少ない'],
      ['luck', '運'],
      ['luckily', '幸運にも'],
      ['luckless', '不運な'],
      ['lucky', '幸運な'],
      ["ma'am", '奥様'],
      ['made', '作った'],
      ['make', '作る'],
      ['Maybe', 'たぶん'],
      ['maybe', 'たぶん'],
      ['me', '私を'],
      ['meaning', '意味'],
      ['memory', '記憶'],
      ['meself', '自分自身（方言）'],
      ['Mind', '心'],
      ['mind', '心'],
      ['mineself', '自分自身（方言）'],
      ['model', '模型'],
      ['myself', '自分自身'],
      ['off', '離れて'],
      ['on', '～の上で'],
      ['oneself', '自分自身'],
      ['order', '注文'],
      ['ordered', '注文した'],
      ['out', '外へ'],
      ['paid', '支払った'],
      ['passenger', '乗客'],
      ['passengers', '乗客たち'],
      ['Passengers', '乗客たち'],
      ['patter', '模様（誤字）'],
      ['pattern', '模様'],
      ['pay', '支払う'],
      ['perfect', '完璧な'],
      ['perfectly', '完璧に'],
      ['Perhaps', 'おそらく'],
      ['perhaps', 'おそらく'],
      ['pick', '拾う'],
      ['picked', '拾った'],
      ['picking', '拾っている'],
      ['possible', '可能な'],
      ['precious', '貴重な'],
      ['president', '大統領'],
      ['presidents', '大統領たち'],
      ['probably', 'たぶん'],
      ['professional', '専門家'],
      ['pulled', '引いた'],
      ['pulling', '引いている'],
      ['put', '置く'],
      ['Put', '置く'],
      ['rang', '鳴った'],
      ['ray', '光線'],
      ['reason', '理由'],
      ['receive', '受け取る'],
      ['received', '受け取った'],
      ['relative', '親戚'],
      ['relatives', '親戚たち'],
      ['Relatives', '親戚たち'],
      ['ring', '鳴る'],
      ['ringing', '鳴っている'],
      ['rub', 'こする'],
      ['rubbed', 'こすった'],
      ['rubbing', 'こすっている'],
      ['rung', '鳴らされた'],
      ['sample', '標本'],
      ['sense', '感覚'],
      ['senses', '感覚'],
      ['several', 'いくつかの'],
      ['shade', '日陰'],
      ['shades', '日陰'],
      ['shadow', '影'],
      ['shape', '形'],
      ['sick', '病気の'],
      ['silver', '銀'],
      ['sir', '旦那様'],
      ['source', '源'],
      ['sources', '源'],
      ['spirit', '精神'],
      ['suffer', '苦しむ'],
      ['suffered', '苦しんだ'],
      ['suffering', '苦しむこと'],
      ['sure of', '～を確信している'],
      ['surprised', '驚いた'],
      ['surprising', '驚くべき'],
      ['surprisingly', '驚くほど'],
      ['swimming', '泳ぐこと'],
      ['swing', '揺らす'],
      ['swinging', '揺れている'],
      ['swung', '揺らした'],
      ['tempreature', '温度'],
      ['themselves', '彼ら自身'],
      ['to laugh', '笑うこと'],
      ['truth', '真実'],
      ['tube', '管'],
      ['unable', 'できない'],
      ['Unfair', '不公平な'],
      ['unfair', '不公平な'],
      ['Unknown', '未知の'],
      ['unknown', '未知の'],
      ['Unlike', '～と違って'],
      ['unlike', '～と違って'],
      ['up', '上へ'],
      ['up for', '～に備えて'],
      ['up with', '～と一緒に'],
      ['up your mind', '決心する'],
      ['weak', '弱い'],
      ['whole', '全体の'],
      ['wise', '賢い'],
      ['with', '～と一緒に'],
      ['yourself', 'あなた自身'],
      ['yourselves', 'あなたがた自身'],
      ['youth', '若者'],
    ]);

    const QUESTION_TRANSLATION_FALLBACKS = new Map([
      ['#NAME?', '（問題文が壊れています）'],
    ]);

    const statusEl = document.querySelector('[data-status]');
    const translationChoiceSection = document.querySelector('[data-translation-choice]');
    const quizSection = document.querySelector('[data-quiz]');
    const questionEl = document.querySelector('[data-question]');
    const optionsEl = document.querySelector('[data-options]');
    const feedbackEl = document.querySelector('[data-feedback]');
    const nextButton = document.querySelector('[data-next]');
    const toggleTimerButton = document.querySelector('[data-toggle-timer]');
    const toggleTranslationButton = document.querySelector('[data-toggle-translation]');
    const toggleModeButton = document.querySelector('[data-toggle-mode]');
    const shuffleButton = document.querySelector('[data-shuffle-order]');
    const correctEl = document.querySelector('[data-correct]');
    const totalEl = document.querySelector('[data-total]');
    const optionTemplate = document.getElementById('option-button-template');

    document.body.classList.add('translations-hidden');

    let allQuestions = [];
    let questionIndexById = new Map();
    let questionStats = new Map();
    const wrongQuestionIds = new Set();

    let order = [];
    let orderPointer = 0;
    let currentQuestion = null;
    let currentQuestionIndex = null;
    let answered = false;
    let correctCount = 0;
    let totalCount = 0;
    let showTranslations = false;
    let quizStarted = false;
    let autoAdvanceTimer = null;
    let autoAdvanceEnabled = true;
    let quizMode = 'all';

    translationChoiceSection?.addEventListener('click', handleTranslationChoice);
    nextButton.addEventListener('click', handleNextClick);
    toggleTimerButton?.addEventListener('click', handleToggleTimer);
    toggleTranslationButton?.addEventListener('click', handleToggleTranslation);
    toggleModeButton?.addEventListener('click', handleToggleMode);
    shuffleButton?.addEventListener('click', handleShuffleOrder);

    init().catch((error) => {
      console.error(error);
      statusEl.textContent = `読み込み中に問題が発生しました: ${error.message}`;
      statusEl.classList.add('app__status--error');
    });

    async function init() {
      try {
        const dataset = QUESTION_DATASETS[0];
        const datasetQuestions = await loadDataset(dataset);
        if (!datasetQuestions.length) {
          throw new Error('問題が1問も読み込めませんでした。');
        }
        allQuestions = datasetQuestions;
        questionIndexById = new Map();
        questionStats = new Map();
        wrongQuestionIds.clear();
        allQuestions.forEach((question, index) => {
          questionIndexById.set(question.id, index);
          questionStats.set(question.id, { attempts: 0, correct: 0 });
        });
    prepareOrder(getAllQuestionIndexes());
    updateTimerToggleLabel();
    updateTranslationToggleLabel();
    updateModeToggleLabel();
    updateShuffleButtonState();
        statusEl.textContent = '日本語訳を表示するか選んでください。';
        translationChoiceSection.hidden = false;
      } catch (error) {
        throw error;
      }
    }

    async function loadDataset(dataset) {
      const translationPromise = dataset.translationFile
        ? loadTranslationRows(dataset.translationFile)
        : Promise.resolve([]);
      const [questionRows, translationRows] = await Promise.all([
        loadQuestionRows(dataset.questionFile),
        translationPromise,
      ]);
      return mergeQuestionData(questionRows, translationRows, dataset.id);
    }

    async function loadQuestionRows(path) {
      const response = await fetch(path, { cache: 'no-store' });
      if (!response.ok) {
        throw new Error(`CSVの取得に失敗しました (HTTP ${response.status})`);
      }
      const rawText = await response.text();
      const rows = parseCsv(rawText);
      const header = rows[0] || [];
      const hasHeader = header.map((cell) => cell.trim().toLowerCase()).includes('anum');
      const questionRows = hasHeader ? rows.slice(1) : rows;
      return questionRows
        .map((cols) => normalizeRow(cols))
        .filter((item) => item !== null);
    }

    async function loadTranslationRows(path) {
      const response = await fetch(path, { cache: 'no-store' });
      if (!response.ok) {
        throw new Error(`翻訳データの取得に失敗しました (HTTP ${response.status})`);
      }
      const data = await response.json();
      if (!Array.isArray(data)) {
        throw new Error('翻訳データの形式が正しくありません。');
      }
      return data;
    }

    function mergeQuestionData(englishRows, translationRows, datasetId) {
      const merged = [];
      for (let index = 0; index < englishRows.length; index += 1) {
        const english = englishRows[index];
        if (!english || !english.question || english.question.includes('#NAME?')) {
          continue;
        }
        const translation = translationRows[index] ?? {};
        const questionTranslation = resolveQuestionTranslation(english.question, translation.question);
        const optionTranslations = english.options.map((optionText, optionIndex) => {
          const rawTranslation = translation.options?.[optionIndex] ?? null;
          return resolveOptionTranslation(optionText, rawTranslation);
        });
        merged.push({
          id: `${datasetId}-${index}`,
          question: english.question,
          options: english.options,
          answerIndex: english.answerIndex,
          translation: {
            question: questionTranslation,
            options: optionTranslations,
          },
        });
      }
      return merged;
    }

    function handleTranslationChoice(event) {
      const button = event.target.closest('button[data-translation-option]');
      if (!button || quizStarted || !allQuestions.length) {
        return;
      }
      const { translationOption } = button.dataset;
      if (!translationOption) {
        return;
      }
      startQuiz(translationOption === 'show');
    }

    function startQuiz(enableTranslations) {
      showTranslations = enableTranslations;
      quizStarted = true;
      translationChoiceSection.hidden = true;
      quizSection.hidden = false;
      correctCount = 0;
      totalCount = 0;
      updateScoreboard();
      updateTranslationToggleLabel();
      updateTimerToggleLabel();
      setQuizMode('all', { silent: true });
      statusEl.textContent = `全 ${allQuestions.length} 問から出題します。`;
      showNextQuestion();
    }

    function setQuizMode(mode, options = {}) {
      const silent = Boolean(options.silent);
      if (mode === 'wrong-only') {
        const wrongIndexes = getWrongQuestionIndexes();
        if (!wrongIndexes.length) {
          if (!silent) {
            statusEl.textContent = '誤答した問題はありません。';
          }
          updateModeToggleLabel();
          updateShuffleButtonState();
          return;
        }
        quizMode = 'wrong-only';
        if (!silent) {
          statusEl.textContent = '誤答した問題のみ出題します。';
        }
        prepareOrder(wrongIndexes);
        updateModeToggleLabel();
        return;
      }
      quizMode = 'all';
      if (!silent) {
        statusEl.textContent = `全 ${allQuestions.length} 問から出題します。`;
      }
      prepareOrder(getAllQuestionIndexes());
      updateModeToggleLabel();
    }

    function prepareOrder(poolIndexes) {
      let candidateIndexes = poolIndexes.slice();
      if (candidateIndexes.length > 1 && currentQuestionIndex !== null) {
        const filtered = candidateIndexes.filter((index) => index !== currentQuestionIndex);
        if (filtered.length) {
          candidateIndexes = filtered;
        }
      }
      order = shuffle(candidateIndexes);
      orderPointer = 0;
      updateShuffleButtonState();
    }

    function showNextQuestion() {
      if (autoAdvanceTimer !== null) {
        window.clearTimeout(autoAdvanceTimer);
        autoAdvanceTimer = null;
      }
      if (!allQuestions.length) {
        return;
      }
      let poolIndexes = getActivePoolIndexes();
      if (!poolIndexes.length) {
        if (quizMode === 'wrong-only') {
          statusEl.textContent = '誤答した問題はありません。全問題モードに戻ります。';
          setQuizMode('all', { silent: true });
          poolIndexes = getActivePoolIndexes();
        }
        if (!poolIndexes.length) {
          questionEl.innerHTML = '<span class="quiz__question-text">出題できる問題がありません。</span>';
          optionsEl.innerHTML = '';
          return;
        }
      }
      if (orderPointer >= order.length) {
        prepareOrder(poolIndexes);
      }
      if (!order.length) {
        return;
      }
      const questionIndex = order[orderPointer];
      orderPointer += 1;
      currentQuestionIndex = questionIndex;
      currentQuestion = allQuestions[questionIndex];
      answered = false;
      nextButton.disabled = true;
      feedbackEl.textContent = '';
      feedbackEl.className = 'quiz__feedback';
      renderQuestion(currentQuestion);
      renderOptions(currentQuestion);
      updateShuffleButtonState();
    }

    function renderQuestion(question) {
      let markup = `<span class="quiz__question-text">${formatText(question.question)}</span>`;
      const translationText = question.translation.question;
      if (hasMeaningfulText(translationText)) {
        markup += `<span class="quiz__question-translation">${formatText(translationText)}</span>`;
      }
      questionEl.innerHTML = markup;
    }

    function renderOptions(question) {
      optionsEl.innerHTML = '';
      question.options.forEach((optionText, index) => {
        const button = optionTemplate.content.firstElementChild.cloneNode(true);
        const translationText = question.translation.options[index];
        let optionMarkup = `<span class="quiz__option-text">${formatText(optionText)}</span>`;
        if (hasMeaningfulText(translationText)) {
          optionMarkup += `<span class="quiz__option-translation">${formatText(translationText)}</span>`;
        }
        button.innerHTML = optionMarkup;
        button.dataset.index = String(index);
        button.addEventListener('click', () => handleOptionClick(button, index));
        optionsEl.appendChild(button);
      });
    }

    function handleOptionClick(button, selectedIndex) {
      if (answered) {
        return;
      }
      answered = true;
      totalCount += 1;

      const questionId = currentQuestion.id;
      const stats = questionStats.get(questionId) ?? { attempts: 0, correct: 0 };
      stats.attempts += 1;

      const isCorrect = selectedIndex === currentQuestion.answerIndex;
      if (isCorrect) {
        correctCount += 1;
        stats.correct += 1;
        wrongQuestionIds.delete(questionId);
        feedbackEl.textContent = '正解！';
        feedbackEl.classList.add('quiz__feedback--correct');
      } else {
        wrongQuestionIds.add(questionId);
        feedbackEl.textContent = '残念！正答を確認しましょう。';
        feedbackEl.classList.add('quiz__feedback--wrong');
      }
      questionStats.set(questionId, stats);

      [...optionsEl.children].forEach((optionButton, index) => {
        optionButton.disabled = true;
        if (index === currentQuestion.answerIndex) {
          optionButton.classList.add('quiz__option--correct');
        }
        if (index === selectedIndex && !isCorrect) {
          optionButton.classList.add('quiz__option--wrong');
        }
      });

      nextButton.disabled = false;
      updateScoreboard();
      updateModeToggleLabel();
      updateShuffleButtonState();

      if (quizMode === 'wrong-only') {
        if (wrongQuestionIds.size === 0) {
          statusEl.textContent = '誤答した問題はすべて解き終わりました。全問題モードに戻ります。';
          setQuizMode('all', { silent: true });
        } else {
          prepareOrder(getActivePoolIndexes());
        }
      } else if (orderPointer >= order.length) {
        prepareOrder(getActivePoolIndexes());
      }

      if (autoAdvanceEnabled) {
        autoAdvanceTimer = window.setTimeout(() => {
          autoAdvanceTimer = null;
          showNextQuestion();
        }, 600);
      }
    }

    function handleNextClick() {
      if (autoAdvanceTimer !== null) {
        window.clearTimeout(autoAdvanceTimer);
        autoAdvanceTimer = null;
      }
      showNextQuestion();
    }

    function handleToggleTimer() {
      autoAdvanceEnabled = !autoAdvanceEnabled;
      if (!autoAdvanceEnabled && autoAdvanceTimer !== null) {
        window.clearTimeout(autoAdvanceTimer);
        autoAdvanceTimer = null;
      }
      updateTimerToggleLabel();
    }

    function handleToggleTranslation() {
      showTranslations = !showTranslations;
      updateTranslationToggleLabel();
    }

    function handleToggleMode() {
      const targetMode = quizMode === 'all' ? 'wrong-only' : 'all';
      setQuizMode(targetMode);
    }

    function handleShuffleOrder() {
      if (!quizStarted) {
        return;
      }
      const poolIndexes = getActivePoolIndexes();
      if (poolIndexes.length <= 1) {
        statusEl.textContent = poolIndexes.length === 0
          ? 'シャッフルできる問題がありません。'
          : 'シャッフルするのに十分な問題がありません。';
        return;
      }
      prepareOrder(poolIndexes);
      statusEl.textContent = '出題順をシャッフルしました。';
    }

    function updateTimerToggleLabel() {
      if (!toggleTimerButton) {
        return;
      }
      toggleTimerButton.textContent = `自動で進む: ${autoAdvanceEnabled ? 'ON' : 'OFF'}`;
    }

    function updateTranslationToggleLabel() {
      if (!toggleTranslationButton) {
        return;
      }
      toggleTranslationButton.textContent = `日本語: ${showTranslations ? '表示' : '非表示'}`;
      document.body.classList.toggle('translations-hidden', !showTranslations);
    }

    function updateModeToggleLabel() {
      if (!toggleModeButton) {
        return;
      }
      const isWrongOnly = quizMode === 'wrong-only';
      const hasWrongQuestions = wrongQuestionIds.size > 0;
      toggleModeButton.textContent = `誤答のみ: ${isWrongOnly ? 'ON' : 'OFF'}`;
      toggleModeButton.disabled = !isWrongOnly && !hasWrongQuestions;
    }

    function updateScoreboard() {
      correctEl.textContent = String(correctCount);
      totalEl.textContent = String(totalCount);
    }

    function updateShuffleButtonState() {
      if (!shuffleButton) {
        return;
      }
      const poolIndexes = getActivePoolIndexes();
      const canShuffle = quizStarted && poolIndexes.length > 1;
      shuffleButton.disabled = !canShuffle;
    }

    function getAllQuestionIndexes() {
      return allQuestions.map((_, index) => index);
    }

    function getWrongQuestionIndexes() {
      return [...wrongQuestionIds]
        .map((id) => questionIndexById.get(id))
        .filter((index) => index !== undefined);
    }

    function getActivePoolIndexes() {
      return quizMode === 'wrong-only' ? getWrongQuestionIndexes() : getAllQuestionIndexes();
    }

    function resolveQuestionTranslation(englishText, rawTranslation) {
      if (hasMeaningfulText(rawTranslation)) {
        return rawTranslation.trim();
      }
      const key = (englishText ?? '').trim();
      return QUESTION_TRANSLATION_FALLBACKS.get(key) ?? null;
    }

    function resolveOptionTranslation(englishText, rawTranslation) {
      if (hasMeaningfulText(rawTranslation)) {
        return rawTranslation.trim();
      }
      const key = (englishText ?? '').trim();
      return OPTION_TRANSLATION_FALLBACKS.get(key) ?? null;
    }

    function hasMeaningfulText(value) {
      if (value === null || value === undefined) {
        return false;
      }
      const trimmed = String(value).trim();
      if (!trimmed) {
        return false;
      }
      return trimmed !== '?' && trimmed !== '？';
    }

    function normalizeRow(cols) {
      if (!cols || cols.length < 6) {
        return null;
      }
      const [rawQuestion, ...optionAndAnswer] = cols;
      const options = optionAndAnswer.slice(0, 4);
      const answerRaw = optionAndAnswer[4];
      const answerIndex = Number.parseInt(answerRaw, 10) - 1;
      if (Number.isNaN(answerIndex) || answerIndex < 0 || answerIndex > 3) {
        return null;
      }
      return {
        question: rawQuestion.trim(),
        options: options.map((option) => option.trim()),
        answerIndex,
      };
    }

    function parseCsv(text) {
      if (!text) {
        return [];
      }
      const rows = [];
      let row = [];
      let value = '';
      let insideQuotes = false;
      let i = 0;

      if (text.charCodeAt(0) === 0xfeff) {
        text = text.slice(1);
      }

      while (i < text.length) {
        const char = text[i];

        if (char === '"') {
          const peek = text[i + 1];
          if (insideQuotes && peek === '"') {
            value += '"';
            i += 2;
            continue;
          }
          insideQuotes = !insideQuotes;
          i += 1;
          continue;
        }

        if (char === ',' && !insideQuotes) {
          row.push(value);
          value = '';
          i += 1;
          continue;
        }

        if ((char === '\n' || char === '\r') && !insideQuotes) {
          if (char === '\r' && text[i + 1] === '\n') {
            i += 1;
          }
          row.push(value);
          rows.push(row);
          row = [];
          value = '';
          i += 1;
          continue;
        }

        value += char;
        i += 1;
      }

      if (value.length > 0 || row.length > 0) {
        row.push(value);
        rows.push(row);
      }

      return rows.filter((r) => r.some((cell) => cell.trim() !== ''));
    }

    function shuffle(array) {
      const copy = array.slice();
      for (let i = copy.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [copy[i], copy[j]] = [copy[j], copy[i]];
      }
      return copy;
    }

    function formatText(text) {
      return escapeHtml(text).replace(/\r?\n/g, '<br>');
    }

    function escapeHtml(text) {
      const safeText = String(text ?? '');
      return safeText.replace(/[&<>"']/g, (char) => {
        switch (char) {
          case '&':
            return '&amp;';
          case '<':
            return '&lt;';
          case '>':
            return '&gt;';
          case '"':
            return '&quot;';
          case '\'':
            return '&#39;';
          default:
            return char;
        }
      });
    }
  </script>
